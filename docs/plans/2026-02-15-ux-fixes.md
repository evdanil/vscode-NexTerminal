# UX Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix four UX issues: allow multi-session connect, rename "Tunnel Patch Bay" to "Port Forwarding", use circle-based tunnel state icons, and replace sequential input prompts with webview forms.

**Architecture:** Tasks 1-3 are small targeted changes to `package.json` and tree providers. Task 4 adds a reusable `WebviewFormPanel` class and three form renderers (server, tunnel, serial), then rewires command handlers to use them instead of sequential input prompts.

**Tech Stack:** VS Code Extension API (WebviewPanel, postMessage), pure HTML/CSS with VS Code CSS variables, TypeScript.

---

### Task 1: Allow "Connect" on already-connected servers

**Files:**
- Modify: `package.json:194-209` (menus → view/item/context)

**Step 1: Add inline connect action for connected servers**

In `package.json`, in the `"view/item/context"` array, add a new entry right after the existing `nexus.server.connect` entry for `nexus.server` (line 199). Insert:

```json
{
  "command": "nexus.server.connect",
  "when": "view == nexusCommandCenter && viewItem == nexus.serverConnected",
  "group": "inline"
}
```

This goes between the existing `nexus.server.connect` (for `nexus.server`) and `nexus.server.disconnect` (for `nexus.serverConnected`) entries. The result: connected servers show both `$(plug)` (connect another) and `$(debug-disconnect)` (disconnect all) inline.

**Step 2: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 3: Commit**

```bash
git add package.json
git commit -m "fix: allow opening additional SSH terminals on connected servers"
```

---

### Task 2: Rename "Tunnel Patch Bay" to "Port Forwarding"

**Files:**
- Modify: `package.json:44` (view name)
- Modify: `src/ui/tunnelMonitorHtml.ts:51` (empty state text)

**Step 1: Rename the view**

In `package.json`, change:
```json
"name": "Tunnel Patch Bay"
```
to:
```json
"name": "Port Forwarding"
```

**Step 2: Update tunnel monitor empty state**

In `src/ui/tunnelMonitorHtml.ts`, change:
```
No active tunnels. Start one from the Tunnel Patch Bay.
```
to:
```
No active tunnels. Start one from Port Forwarding.
```

**Step 3: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 4: Run tests**

Run: `npm test`
Expected: all pass (tunnelMonitorHtml tests may need updating if they check for the old text)

**Step 5: Commit**

```bash
git add package.json src/ui/tunnelMonitorHtml.ts
git commit -m "fix: rename Tunnel Patch Bay to Port Forwarding"
```

---

### Task 3: Circle-based tunnel state icons

**Files:**
- Modify: `src/ui/tunnelTreeProvider.ts:18` (TunnelTreeItem icon)

**Step 1: Change tunnel icons to circle states**

In `src/ui/tunnelTreeProvider.ts`, line 18, change:
```typescript
this.iconPath = new vscode.ThemeIcon(activeTunnelId ? "radio-tower" : "debug-start");
```
to:
```typescript
this.iconPath = new vscode.ThemeIcon(
  activeTunnelId ? "circle-filled" : "circle-outline",
  new vscode.ThemeColor(activeTunnelId ? "testing.iconPassed" : "descriptionForeground")
);
```

This gives:
- Stopped: grey outline circle (clearly "off", not clickable-looking)
- Running: green filled circle (clearly "on")

**Step 2: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 3: Commit**

```bash
git add src/ui/tunnelTreeProvider.ts
git commit -m "fix: use circle icons for tunnel state instead of misleading arrows"
```

---

### Task 4: Form field descriptor types

**Files:**
- Create: `src/ui/formTypes.ts`

**Step 1: Create the form field type definitions**

Create `src/ui/formTypes.ts`:

```typescript
export type FormFieldDescriptor =
  | { type: "text"; key: string; label: string; required?: boolean; placeholder?: string; value?: string }
  | { type: "number"; key: string; label: string; required?: boolean; min?: number; max?: number; placeholder?: string; value?: number }
  | { type: "select"; key: string; label: string; options: { label: string; value: string }[]; value?: string }
  | { type: "checkbox"; key: string; label: string; value?: boolean }
  | { type: "file"; key: string; label: string; value?: string };

export interface FormDefinition {
  title: string;
  fields: FormFieldDescriptor[];
}

export type FormValues = Record<string, string | number | boolean | undefined>;

export type FormMessage =
  | { type: "submit"; values: FormValues }
  | { type: "cancel" }
  | { type: "browse"; key: string };

export type ExtensionMessage =
  | { type: "init"; definition: FormDefinition; values: FormValues }
  | { type: "browseResult"; key: string; path: string }
  | { type: "validationError"; errors: Record<string, string> };
```

**Step 2: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 3: Commit**

```bash
git add src/ui/formTypes.ts
git commit -m "feat: add form field descriptor types for webview forms"
```

---

### Task 5: Form HTML renderer

**Files:**
- Create: `src/ui/formHtml.ts`

**Step 1: Write the form HTML test**

Create `test/unit/formHtml.test.ts`:

```typescript
import { describe, expect, it } from "vitest";
import { renderFormHtml } from "../../src/ui/formHtml";
import type { FormDefinition } from "../../src/ui/formTypes";

describe("renderFormHtml", () => {
  it("renders text fields with labels", () => {
    const definition: FormDefinition = {
      title: "Test Form",
      fields: [
        { type: "text", key: "name", label: "Name", required: true, value: "hello" }
      ]
    };
    const html = renderFormHtml(definition);
    expect(html).toContain("Test Form");
    expect(html).toContain('id="field-name"');
    expect(html).toContain("Name");
    expect(html).toContain("required");
  });

  it("renders select fields with options", () => {
    const definition: FormDefinition = {
      title: "Test",
      fields: [
        {
          type: "select",
          key: "mode",
          label: "Mode",
          options: [
            { label: "Option A", value: "a" },
            { label: "Option B", value: "b" }
          ],
          value: "b"
        }
      ]
    };
    const html = renderFormHtml(definition);
    expect(html).toContain("<select");
    expect(html).toContain("Option A");
    expect(html).toContain("Option B");
    expect(html).toContain("selected");
  });

  it("renders checkbox fields", () => {
    const definition: FormDefinition = {
      title: "Test",
      fields: [{ type: "checkbox", key: "flag", label: "Enable", value: true }]
    };
    const html = renderFormHtml(definition);
    expect(html).toContain('type="checkbox"');
    expect(html).toContain("checked");
  });

  it("renders number fields with min/max", () => {
    const definition: FormDefinition = {
      title: "Test",
      fields: [{ type: "number", key: "port", label: "Port", min: 1, max: 65535, value: 22 }]
    };
    const html = renderFormHtml(definition);
    expect(html).toContain('type="number"');
    expect(html).toContain('min="1"');
    expect(html).toContain('max="65535"');
  });

  it("renders file fields with browse button", () => {
    const definition: FormDefinition = {
      title: "Test",
      fields: [{ type: "file", key: "keyPath", label: "Key File", value: "/home/.ssh/id_rsa" }]
    };
    const html = renderFormHtml(definition);
    expect(html).toContain("Browse");
    expect(html).toContain('id="field-keyPath"');
  });

  it("includes submit and cancel buttons", () => {
    const definition: FormDefinition = {
      title: "Test",
      fields: []
    };
    const html = renderFormHtml(definition);
    expect(html).toContain("Save");
    expect(html).toContain("Cancel");
  });

  it("includes vscode api script", () => {
    const definition: FormDefinition = {
      title: "Test",
      fields: []
    };
    const html = renderFormHtml(definition);
    expect(html).toContain("acquireVsCodeApi");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run test/unit/formHtml.test.ts`
Expected: FAIL — module not found

**Step 3: Implement the form HTML renderer**

Create `src/ui/formHtml.ts`:

```typescript
import type { FormDefinition, FormFieldDescriptor } from "./formTypes";

function escapeHtml(value: string): string {
  return value
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function renderField(field: FormFieldDescriptor): string {
  const id = `field-${field.key}`;
  const req = "required" in field && field.required ? " required" : "";

  switch (field.type) {
    case "text":
      return `<div class="form-group">
  <label for="${id}">${escapeHtml(field.label)}${"required" in field && field.required ? ' <span class="req">*</span>' : ""}</label>
  <input type="text" id="${id}" name="${field.key}" value="${escapeHtml(field.value ?? "")}" placeholder="${escapeHtml(field.placeholder ?? "")}"${req} />
  <div class="field-error" id="error-${field.key}"></div>
</div>`;

    case "number":
      return `<div class="form-group">
  <label for="${id}">${escapeHtml(field.label)}${"required" in field && field.required ? ' <span class="req">*</span>' : ""}</label>
  <input type="number" id="${id}" name="${field.key}" value="${field.value ?? ""}" min="${field.min ?? ""}" max="${field.max ?? ""}" placeholder="${escapeHtml(field.placeholder ?? "")}"${req} />
  <div class="field-error" id="error-${field.key}"></div>
</div>`;

    case "select":
      return `<div class="form-group">
  <label for="${id}">${escapeHtml(field.label)}</label>
  <select id="${id}" name="${field.key}">
    ${field.options.map((opt) => `<option value="${escapeHtml(opt.value)}"${opt.value === field.value ? " selected" : ""}>${escapeHtml(opt.label)}</option>`).join("\n    ")}
  </select>
  <div class="field-error" id="error-${field.key}"></div>
</div>`;

    case "checkbox":
      return `<div class="form-group form-group-checkbox">
  <label>
    <input type="checkbox" id="${id}" name="${field.key}"${field.value ? " checked" : ""} />
    ${escapeHtml(field.label)}
  </label>
</div>`;

    case "file":
      return `<div class="form-group">
  <label for="${id}">${escapeHtml(field.label)}</label>
  <div class="file-input-row">
    <input type="text" id="${id}" name="${field.key}" value="${escapeHtml(field.value ?? "")}" readonly />
    <button type="button" class="browse-btn" data-key="${field.key}">Browse</button>
  </div>
  <div class="field-error" id="error-${field.key}"></div>
</div>`;
  }
}

export function renderFormHtml(definition: FormDefinition): string {
  const fieldsHtml = definition.fields.map(renderField).join("\n");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size, 13px);
      background: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      margin: 0;
      padding: 20px;
      max-width: 520px;
    }
    h2 {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 20px 0;
    }
    .form-group {
      margin-bottom: 14px;
    }
    .form-group-checkbox {
      margin-top: 8px;
    }
    label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      font-size: 12px;
      color: var(--vscode-foreground);
    }
    .form-group-checkbox label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 13px;
    }
    .req { color: var(--vscode-errorForeground); }
    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 5px 8px;
      background: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border, transparent);
      border-radius: 2px;
      font-family: inherit;
      font-size: 13px;
      outline: none;
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: var(--vscode-focusBorder);
    }
    input[type="checkbox"] {
      accent-color: var(--vscode-focusBorder);
    }
    .file-input-row {
      display: flex;
      gap: 6px;
    }
    .file-input-row input {
      flex: 1;
    }
    .browse-btn {
      padding: 5px 12px;
      background: var(--vscode-button-secondaryBackground, var(--vscode-button-background));
      color: var(--vscode-button-secondaryForeground, var(--vscode-button-foreground));
      border: none;
      border-radius: 2px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    .browse-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground, var(--vscode-button-hoverBackground));
    }
    .field-error {
      color: var(--vscode-errorForeground);
      font-size: 11px;
      margin-top: 3px;
      min-height: 0;
    }
    .actions {
      margin-top: 22px;
      display: flex;
      gap: 8px;
    }
    .btn-primary {
      padding: 6px 16px;
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 2px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .btn-primary:hover {
      background: var(--vscode-button-hoverBackground);
    }
    .btn-secondary {
      padding: 6px 16px;
      background: var(--vscode-button-secondaryBackground, transparent);
      color: var(--vscode-button-secondaryForeground, var(--vscode-foreground));
      border: 1px solid var(--vscode-input-border, var(--vscode-panel-border));
      border-radius: 2px;
      cursor: pointer;
      font-size: 13px;
    }
    .btn-secondary:hover {
      background: var(--vscode-button-secondaryHoverBackground, var(--vscode-list-hoverBackground));
    }
  </style>
</head>
<body>
  <h2>${escapeHtml(definition.title)}</h2>
  <form id="nexus-form">
    ${fieldsHtml}
    <div class="actions">
      <button type="submit" class="btn-primary">Save</button>
      <button type="button" class="btn-secondary" id="cancel-btn">Cancel</button>
    </div>
  </form>
  <script>
    (function() {
      const vscode = acquireVsCodeApi();
      const form = document.getElementById("nexus-form");

      form.addEventListener("submit", (e) => {
        e.preventDefault();
        const values = {};
        for (const el of form.elements) {
          if (!el.name) continue;
          if (el.type === "checkbox") {
            values[el.name] = el.checked;
          } else if (el.type === "number") {
            values[el.name] = el.value === "" ? undefined : Number(el.value);
          } else {
            values[el.name] = el.value;
          }
        }
        vscode.postMessage({ type: "submit", values: values });
      });

      document.getElementById("cancel-btn").addEventListener("click", () => {
        vscode.postMessage({ type: "cancel" });
      });

      for (const btn of document.querySelectorAll(".browse-btn")) {
        btn.addEventListener("click", () => {
          vscode.postMessage({ type: "browse", key: btn.dataset.key });
        });
      }

      window.addEventListener("message", (event) => {
        const msg = event.data;
        if (msg.type === "browseResult") {
          const input = document.getElementById("field-" + msg.key);
          if (input) input.value = msg.path;
        }
        if (msg.type === "validationError") {
          for (const errEl of document.querySelectorAll(".field-error")) {
            errEl.textContent = "";
          }
          for (const [key, message] of Object.entries(msg.errors)) {
            const errEl = document.getElementById("error-" + key);
            if (errEl) errEl.textContent = message;
          }
        }
      });
    })();
  </script>
</body>
</html>`;
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run test/unit/formHtml.test.ts`
Expected: all 7 tests PASS

**Step 5: Commit**

```bash
git add src/ui/formHtml.ts test/unit/formHtml.test.ts
git commit -m "feat: add form HTML renderer for webview forms"
```

---

### Task 6: WebviewFormPanel class

**Files:**
- Create: `src/ui/webviewFormPanel.ts`

**Step 1: Implement the webview form panel**

Create `src/ui/webviewFormPanel.ts`:

```typescript
import * as vscode from "vscode";
import { renderFormHtml } from "./formHtml";
import type { FormDefinition, FormMessage, FormValues } from "./formTypes";

export class WebviewFormPanel {
  private static activePanels = new Map<string, WebviewFormPanel>();
  private readonly panel: vscode.WebviewPanel;
  private disposed = false;

  private constructor(
    private readonly formId: string,
    definition: FormDefinition,
    private readonly onSubmit: (values: FormValues) => void,
    private readonly onCancel: () => void,
    private readonly onBrowse?: (key: string) => Promise<string | undefined>
  ) {
    this.panel = vscode.window.createWebviewPanel(
      `nexus.form.${formId}`,
      definition.title,
      vscode.ViewColumn.Active,
      { enableScripts: true, retainContextWhenHidden: false }
    );

    this.panel.webview.html = renderFormHtml(definition);

    this.panel.webview.onDidReceiveMessage(async (message: FormMessage) => {
      if (message.type === "submit") {
        this.onSubmit(message.values);
        this.dispose();
        return;
      }
      if (message.type === "cancel") {
        this.onCancel();
        this.dispose();
        return;
      }
      if (message.type === "browse" && this.onBrowse) {
        const result = await this.onBrowse(message.key);
        if (result && !this.disposed) {
          void this.panel.webview.postMessage({ type: "browseResult", key: message.key, path: result });
        }
      }
    });

    this.panel.onDidDispose(() => {
      this.disposed = true;
      WebviewFormPanel.activePanels.delete(formId);
    });
  }

  public static open(
    formId: string,
    definition: FormDefinition,
    options: {
      onSubmit: (values: FormValues) => void;
      onCancel?: () => void;
      onBrowse?: (key: string) => Promise<string | undefined>;
    }
  ): WebviewFormPanel {
    const existing = WebviewFormPanel.activePanels.get(formId);
    if (existing) {
      existing.panel.reveal();
      return existing;
    }
    const instance = new WebviewFormPanel(
      formId,
      definition,
      options.onSubmit,
      options.onCancel ?? (() => {}),
      options.onBrowse
    );
    WebviewFormPanel.activePanels.set(formId, instance);
    return instance;
  }

  public sendValidationErrors(errors: Record<string, string>): void {
    if (!this.disposed) {
      void this.panel.webview.postMessage({ type: "validationError", errors });
    }
  }

  public dispose(): void {
    if (!this.disposed) {
      this.panel.dispose();
    }
  }
}
```

**Step 2: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 3: Commit**

```bash
git add src/ui/webviewFormPanel.ts
git commit -m "feat: add WebviewFormPanel for managing form webview lifecycle"
```

---

### Task 7: Form definitions for server, tunnel, serial

**Files:**
- Create: `src/ui/formDefinitions.ts`

**Step 1: Implement the form definitions**

Create `src/ui/formDefinitions.ts`. This file exports functions that build `FormDefinition` objects for each config type.

```typescript
import type { SerialProfile, ServerConfig, TunnelProfile } from "../models/config";
import type { FormDefinition } from "./formTypes";

export function serverFormDefinition(seed?: Partial<ServerConfig>, existingGroups?: string[]): FormDefinition {
  const isEdit = Boolean(seed?.id);
  const groupOptions = [
    { label: "(No group)", value: "" },
    ...(existingGroups ?? []).map((g) => ({ label: g, value: g }))
  ];

  return {
    title: isEdit ? "Edit Server" : "Add Server",
    fields: [
      { type: "text", key: "name", label: "Name", required: true, placeholder: "My Server", value: seed?.name },
      { type: "text", key: "host", label: "Host", required: true, placeholder: "192.168.1.100 or hostname", value: seed?.host },
      { type: "number", key: "port", label: "Port", required: true, min: 1, max: 65535, value: seed?.port ?? 22 },
      { type: "text", key: "username", label: "Username", required: true, placeholder: "root", value: seed?.username },
      {
        type: "select",
        key: "authType",
        label: "Authentication",
        options: [
          { label: "Password", value: "password" },
          { label: "Private Key", value: "key" },
          { label: "SSH Agent", value: "agent" }
        ],
        value: seed?.authType ?? "password"
      },
      { type: "file", key: "keyPath", label: "Private Key File", value: seed?.keyPath },
      {
        type: "select",
        key: "group",
        label: "Group",
        options: groupOptions,
        value: seed?.group ?? ""
      },
      { type: "checkbox", key: "isHidden", label: "Hidden (jump host — not shown in server list)", value: seed?.isHidden ?? false }
    ]
  };
}

export function tunnelFormDefinition(seed?: Partial<TunnelProfile>): FormDefinition {
  const isEdit = Boolean(seed?.id);

  return {
    title: isEdit ? "Edit Tunnel" : "Add Tunnel",
    fields: [
      { type: "text", key: "name", label: "Name", required: true, placeholder: "Database tunnel", value: seed?.name },
      { type: "number", key: "localPort", label: "Local Port", required: true, min: 1, max: 65535, placeholder: "5432", value: seed?.localPort },
      { type: "text", key: "remoteIP", label: "Remote IP", required: true, placeholder: "127.0.0.1", value: seed?.remoteIP ?? "127.0.0.1" },
      { type: "number", key: "remotePort", label: "Remote Port", required: true, min: 1, max: 65535, placeholder: "5432", value: seed?.remotePort },
      { type: "checkbox", key: "autoStart", label: "Auto-start when server connects", value: seed?.autoStart ?? false },
      {
        type: "select",
        key: "connectionMode",
        label: "Connection Mode",
        options: [
          { label: "Isolated (one SSH connection per tunnel client)", value: "isolated" },
          { label: "Shared (single SSH connection for all clients)", value: "shared" },
          { label: "Ask every time", value: "ask" }
        ],
        value: seed?.connectionMode ?? "isolated"
      }
    ]
  };
}

export function serialFormDefinition(seed?: Partial<SerialProfile>, existingGroups?: string[]): FormDefinition {
  const isEdit = Boolean(seed?.id);
  const groupOptions = [
    { label: "(No group)", value: "" },
    ...(existingGroups ?? []).map((g) => ({ label: g, value: g }))
  ];

  return {
    title: isEdit ? "Edit Serial Profile" : "Add Serial Profile",
    fields: [
      { type: "text", key: "name", label: "Name", required: true, placeholder: "Arduino", value: seed?.name },
      { type: "text", key: "path", label: "Port Path", required: true, placeholder: "COM3 or /dev/ttyUSB0", value: seed?.path },
      {
        type: "select",
        key: "baudRate",
        label: "Baud Rate",
        options: [
          { label: "9600", value: "9600" },
          { label: "19200", value: "19200" },
          { label: "38400", value: "38400" },
          { label: "57600", value: "57600" },
          { label: "115200", value: "115200" },
          { label: "230400", value: "230400" },
          { label: "460800", value: "460800" },
          { label: "921600", value: "921600" }
        ],
        value: `${seed?.baudRate ?? 115200}`
      },
      {
        type: "select",
        key: "dataBits",
        label: "Data Bits",
        options: [
          { label: "8", value: "8" },
          { label: "7", value: "7" },
          { label: "6", value: "6" },
          { label: "5", value: "5" }
        ],
        value: `${seed?.dataBits ?? 8}`
      },
      {
        type: "select",
        key: "stopBits",
        label: "Stop Bits",
        options: [
          { label: "1", value: "1" },
          { label: "2", value: "2" }
        ],
        value: `${seed?.stopBits ?? 1}`
      },
      {
        type: "select",
        key: "parity",
        label: "Parity",
        options: [
          { label: "None", value: "none" },
          { label: "Even", value: "even" },
          { label: "Odd", value: "odd" },
          { label: "Mark", value: "mark" },
          { label: "Space", value: "space" }
        ],
        value: seed?.parity ?? "none"
      },
      { type: "checkbox", key: "rtscts", label: "Enable RTS/CTS hardware flow control", value: seed?.rtscts ?? false },
      {
        type: "select",
        key: "group",
        label: "Group",
        options: groupOptions,
        value: seed?.group ?? ""
      }
    ]
  };
}
```

**Step 2: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 3: Commit**

```bash
git add src/ui/formDefinitions.ts
git commit -m "feat: add form definitions for server, tunnel, serial profiles"
```

---

### Task 8: Rewire server commands to use webview forms

**Files:**
- Modify: `src/commands/serverCommands.ts`

**Step 1: Replace prompt calls with webview form**

In `src/commands/serverCommands.ts`:

1. Remove import of `promptServerConfig` from `../ui/prompts`.
2. Add imports:
```typescript
import { randomUUID } from "node:crypto";
import * as os from "node:os";
import type { AuthType, ServerConfig } from "../models/config";
import { serverFormDefinition } from "../ui/formDefinitions";
import { WebviewFormPanel } from "../ui/webviewFormPanel";
import type { FormValues } from "../ui/formTypes";
```

3. Add a helper to convert form values to ServerConfig:
```typescript
function formValuesToServer(values: FormValues, existingId?: string): ServerConfig | undefined {
  const name = typeof values.name === "string" ? values.name.trim() : "";
  const host = typeof values.host === "string" ? values.host.trim() : "";
  const username = typeof values.username === "string" ? values.username.trim() : "";
  if (!name || !host || !username) return undefined;
  return {
    id: existingId ?? randomUUID(),
    name,
    host,
    port: typeof values.port === "number" ? values.port : 22,
    username,
    authType: (values.authType as AuthType) ?? "password",
    keyPath: typeof values.keyPath === "string" && values.keyPath ? values.keyPath : undefined,
    group: typeof values.group === "string" && values.group ? values.group : undefined,
    isHidden: values.isHidden === true
  };
}
```

4. Replace the `nexus.server.add` handler body:
```typescript
vscode.commands.registerCommand("nexus.server.add", () => {
  const existingGroups = collectGroups(ctx);
  const definition = serverFormDefinition(undefined, existingGroups);
  WebviewFormPanel.open("server-add", definition, {
    onSubmit: async (values) => {
      const server = formValuesToServer(values);
      if (!server) return;
      await ctx.core.addOrUpdateServer(server);
    },
    onBrowse: async () => {
      const uris = await vscode.window.showOpenDialog({
        canSelectFiles: true,
        canSelectMany: false,
        title: "Select SSH Private Key",
        defaultUri: vscode.Uri.file(os.homedir() + "/.ssh/"),
        openLabel: "Select Key",
        filters: { "All Files": ["*"] }
      });
      return uris?.[0]?.fsPath;
    }
  });
}),
```

5. Replace the `nexus.server.edit` handler body:
```typescript
vscode.commands.registerCommand("nexus.server.edit", async (arg?: unknown) => {
  const existing = toServerFromArg(ctx.core, arg) ?? (await pickServer(ctx.core));
  if (!existing) return;
  const existingGroups = collectGroups(ctx);
  const definition = serverFormDefinition(existing, existingGroups);
  WebviewFormPanel.open("server-edit", definition, {
    onSubmit: async (values) => {
      const updated = formValuesToServer(values, existing.id);
      if (!updated) return;
      await ctx.core.addOrUpdateServer(updated);
      if (ctx.core.isServerConnected(existing.id)) {
        void vscode.window.showInformationMessage(
          "Server profile updated. Existing sessions keep current connection settings until reconnect."
        );
      }
    },
    onBrowse: async () => {
      const uris = await vscode.window.showOpenDialog({
        canSelectFiles: true,
        canSelectMany: false,
        title: "Select SSH Private Key",
        defaultUri: vscode.Uri.file(os.homedir() + "/.ssh/"),
        openLabel: "Select Key",
        filters: { "All Files": ["*"] }
      });
      return uris?.[0]?.fsPath;
    }
  });
}),
```

**Step 2: Verify build**

Run: `npm run build`
Expected: exit 0

**Step 3: Run tests**

Run: `npm test`
Expected: all pass

**Step 4: Commit**

```bash
git add src/commands/serverCommands.ts
git commit -m "feat: use webview form for server add/edit"
```

---

### Task 9: Rewire tunnel commands to use webview forms

**Files:**
- Modify: `src/commands/tunnelCommands.ts`

**Step 1: Replace prompt calls with webview form**

In `src/commands/tunnelCommands.ts`:

1. Remove import of `promptTunnelProfile` from `../ui/prompts`.
2. Add imports:
```typescript
import { randomUUID } from "node:crypto";
import type { TunnelConnectionMode } from "../models/config";
import { tunnelFormDefinition } from "../ui/formDefinitions";
import { WebviewFormPanel } from "../ui/webviewFormPanel";
import type { FormValues } from "../ui/formTypes";
```

3. Add helper:
```typescript
function formValuesToTunnel(values: FormValues, existingId?: string, defaultServerId?: string): TunnelProfile | undefined {
  const name = typeof values.name === "string" ? values.name.trim() : "";
  if (!name) return undefined;
  return {
    id: existingId ?? randomUUID(),
    name,
    localPort: typeof values.localPort === "number" ? values.localPort : 0,
    remoteIP: typeof values.remoteIP === "string" ? values.remoteIP.trim() : "127.0.0.1",
    remotePort: typeof values.remotePort === "number" ? values.remotePort : 0,
    defaultServerId,
    autoStart: values.autoStart === true,
    connectionMode: (values.connectionMode as TunnelConnectionMode) ?? "isolated"
  };
}
```

4. Replace `nexus.tunnel.add` handler — open form, after submit optionally pick default server, save.

5. Replace `nexus.tunnel.edit` handler — open form pre-filled, after submit check route changes and offer restart.

The logic from the existing handlers (route-change detection, restart prompt) stays the same but is called from the `onSubmit` callback.

**Step 2: Verify build + tests**

Run: `npm run build && npm test`
Expected: all pass

**Step 3: Commit**

```bash
git add src/commands/tunnelCommands.ts
git commit -m "feat: use webview form for tunnel add/edit"
```

---

### Task 10: Rewire serial commands to use webview forms

**Files:**
- Modify: `src/commands/serialCommands.ts`

**Step 1: Replace prompt calls with webview form**

In `src/commands/serialCommands.ts`:

1. Remove import of `promptSerialProfile` from `../ui/prompts`.
2. Add imports:
```typescript
import { randomUUID } from "node:crypto";
import type { SerialDataBits, SerialParity, SerialStopBits } from "../models/config";
import { serialFormDefinition } from "../ui/formDefinitions";
import { WebviewFormPanel } from "../ui/webviewFormPanel";
import type { FormValues } from "../ui/formTypes";
```

3. Add helper:
```typescript
function formValuesToSerial(values: FormValues, existingId?: string): SerialProfile | undefined {
  const name = typeof values.name === "string" ? values.name.trim() : "";
  const portPath = typeof values.path === "string" ? values.path.trim() : "";
  if (!name || !portPath) return undefined;
  return {
    id: existingId ?? randomUUID(),
    name,
    path: portPath,
    baudRate: typeof values.baudRate === "string" ? Number(values.baudRate) : 115200,
    dataBits: (typeof values.dataBits === "string" ? Number(values.dataBits) : 8) as SerialDataBits,
    stopBits: (typeof values.stopBits === "string" ? Number(values.stopBits) : 1) as SerialStopBits,
    parity: (values.parity as SerialParity) ?? "none",
    rtscts: values.rtscts === true,
    group: typeof values.group === "string" && values.group ? values.group : undefined
  };
}
```

4. Replace `nexus.serial.add` and `nexus.serial.edit` handlers to use `WebviewFormPanel.open()` with `serialFormDefinition`.

**Step 2: Verify build + tests**

Run: `npm run build && npm test`
Expected: all pass

**Step 3: Commit**

```bash
git add src/commands/serialCommands.ts
git commit -m "feat: use webview form for serial profile add/edit"
```

---

### Task 11: Clean up old prompt functions

**Files:**
- Modify: `src/ui/prompts.ts`

**Step 1: Remove unused prompt functions**

Delete `promptServerConfig`, `promptTunnelProfile`, `promptSerialProfile`, and their helpers (`stepTitle`, `requiredInput`, `numberInput`, `pickChoice`, `pickOrCreateGroup`). These are no longer called from anywhere.

Keep the file if any other exports remain, or delete it entirely if empty.

**Step 2: Verify build + tests**

Run: `npm run build && npm test`
Expected: all pass (no remaining references to deleted functions)

**Step 3: Commit**

```bash
git add src/ui/prompts.ts
git commit -m "refactor: remove old sequential input prompt functions"
```

---

### Task 12: Final verification

**Step 1: Full build + test**

Run: `npm run build && npm test`
Expected: exit 0, all tests pass

**Step 2: Verify package.json is valid**

Run: `node -e "JSON.parse(require('fs').readFileSync('package.json','utf8'));console.log('valid')"`
Expected: "valid"

**Step 3: Final commit (if any remaining changes)**

```bash
git status
# If clean, done. If not, stage and commit remaining changes.
```
